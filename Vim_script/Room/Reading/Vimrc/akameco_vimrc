" =======================================
" akameco's vimrc
"
" ベース
" http://qiita.com/joker1007/items/9dc7f2a92cfb245ad502
" =======================================
set nocompatible

" 文字コード, 改行コード {{{
set encoding=utf-8
set fileformats=unix,dos,mac
"}}}

" =======================================
" NeoBundle
" =======================================

" NeoBundle{{{
" NeoBundle setting {{{
if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#rc(expand('~/.vim/bundle/'))

filetype off

NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc', {
      \ 'build': {
      \   'mac'       : 'make -f make_mac.mak',
      \   'unix'      : 'make -f make_unix.mak',
      \ }}
" }}}

" Unite {{{
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'thinca/vim-unite-history'
NeoBundleLazy 'Shougo/unite-outline', {
      \ 'depends': ['Shougo/unite.vim'],
      \ 'autoload': {
      \ 'unite_sources': ["outline"],
      \ }}
NeoBundleLazy 'tsukkee/unite-tag', {
      \'autoload' : {'unite_sources' : 'tag' }}
NeoBundleLazy 'pasela/unite-webcolorname', {
      \'autoload' : {'unite_sources' : 'webcolorname' }}
NeoBundleLazy 'ujihisa/unite-colorscheme', {
      \'autoload' : {'unite_sources' : 'colorscheme' }}
"}}}

" neocon{{{
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundleLazy 'Shougo/neocomplete', { 'autoload' : {
      \   'insert' : 1,
      \ }}
"}}}

" colorschemes plugin {{{
NeoBundle 'sjl/badwolf'
NeoBundle 'morhetz/gruvbox'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'baskerville/bubblegum'
NeoBundle 'w0ng/vim-hybrid'
" }}}

" ruby rails{{{
NeoBundle 'thinca/vim-quickrun'
NeoBundleLazy 'vim-ruby/vim-ruby',{ 'autoload':{ 'filetypes': 'ruby'}}
NeoBundleLazy 'tpope/vim-rails',{ 'autoload':{ 'filetypes': 'ruby'}}
NeoBundleLazy 'tpope/vim-endwise',{ 'autoload':{ 'filetypes': 'ruby'}}
NeoBundleLazy 'kchmck/vim-coffee-script', {
      \ 'autoload':{ 'filetypes': 'coffee'}}
NeoBundleLazy 'basyura/unite-rails',{ 'autoload':{ 'filetypes': 'ruby'}}
NeoBundleLazy 'slim-template/vim-slim', {'autoload':{'filetypes': 'slim'}}
"}}}

" ref {{{
NeoBundle 'thinca/vim-ref'
NeoBundle 'taka84u9/vim-ref-ri'
"}}}

" web browse, api {{{
NeoBundle 'tyru/open-browser.vim'
NeoBundle 'mattn/webapi-vim'
NeoBundle 'kannokanno/previm'
" }}}

" カーソル移動{{{
NeoBundle 'rhysd/clever-f.vim'
NeoBundle 'thinca/vim-visualstar'
"}}}

" 編集 {{{
NeoBundle 'godlygeek/tabular'
NeoBundle 'kana/vim-submode'
NeoBundle 'vim-scripts/surround.vim'
NeoBundle 'haya14busa/vim-migemo'
" http://qiita.com/kojionilk/items/a89a067d1d0687451dc7
NeoBundle 'vim-scripts/sudo.vim'        " vim sudo:hoge
NeoBundle 'LeafCage/yankround.vim'
NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'koron/imcsc-vim'             " IM制御

NeoBundleLazy 'AndrewRadev/switch.vim', {
      \   'autoload' : {
      \       'commands' : [ "Switch" ],
      \       'functions' : [ "switch#Switch" ],
      \   }
      \}

NeoBundleLazy 'osyo-manga/vim-anzu', {
      \   'autoload' : {
      \       'mappings' : [
      \'<Plug>(anzu-n-with-echo)',
      \'<Plug>(anzu-N-with-echo)',
      \'<Plug>(anzu-star-with-echo)',
      \'<Plug>(anzu-sharp-with-echo)'
      \       ],
      \   }
      \}
" }}}

" スタイル{{{
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'LeafCage/foldCC'
NeoBundle 'osyo-manga/vim-over'
"}}}

" git {{{
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'gregsexton/gitv'
NeoBundle 'airblade/vim-gitgutter'
NeoBundleLazy 'mattn/gist-vim', {
      \   'autoload' : {
      \       'commands' : [ "Gist" ]
      \   }
      \}
" }}}}

" javascript{{{
NeoBundleLazy 'jiangmiao/simple-javascript-indenter',{
      \'autoload': { 'filetypes': ['javascript'] }}
NeoBundleLazy 'jelera/vim-javascript-syntax',
      \ {'autoload':{ 'filetypes':['javascript'] }}
"}}}

" html {{{
NeoBundleLazy 'othree/html5.vim', {
      \ 'autoload': { 'filetypes': 'html' }}
NeoBundleLazy 'mattn/emmet-vim', {
      \ 'autoload': { 'filetypes': 'html' }}
"}}}

" other plugin {{{
NeoBundle 'rking/ag.vim'
NeoBundle 'osyo-manga/shabadou.vim'
NeoBundle 'godlygeek/tabular'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'vim-scripts/AnsiEsc.vim'
NeoBundle 'majutsushi/tagbar'
NeoBundleLazy 'rcmdnk/vim-markdown', {
      \ 'autoload': { 'filetypes': 'markdown' }}
NeoBundleLazy 'lilydjwg/colorizer', {
      \ 'autoload': { 'filetypes': ['vim', 'html', 'css', 'scss'] }}
" }}}

" textobj {{{
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'kana/vim-niceblock'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle "osyo-manga/vim-textobj-multiblock"
NeoBundleLazy 'nelstrom/vim-textobj-rubyblock', {
      \ 'autoload':{ 'filetypes': 'ruby' }}
NeoBundleLazy 'kana/vim-smartinput', {
      \ 'autoload' : { 'insert' : '1' }}
" }}}

" vimshell, vimfiler {{{
NeoBundleLazy 'Shougo/vimfiler', {
      \   'depends' : 'Shougo/unite.vim',
      \   'autoload' : {
      \       'commands' : [ 'VimFilerTab', 'VimFiler', 'VimFilerExplorer', 'VimFilerBufferDir' ],
      \       'mappings' : ['<Plug>(vimfiler_switch)'],
      \       'explorer' : 1,
      \   }}

NeoBundleLazy 'Shougo/vimshell', {
      \ 'depends' : 'Shougo/vimproc',
      \ 'autoload' : {
      \   'commands' : ['VimShellExecute', 'VimShellPop', 'VimShellBufferDir'],
      \ }}
" }}}

filetype plugin indent on
syntax enable

NeoBundleCheck
"}}}

" augroup init (from tyru's vimrc){{{
augroup vimrc
  autocmd!
augroup END

command!
      \ -bang -nargs=*
      \ MyAutocmd
      \ autocmd<bang> vimrc <args>
"}}}

" color scheme{{{
colorscheme gruvbox
set background=dark
"}}}

" vimrc{{{
" vimrcを素早く読み込み
nnoremap [space].  :<C-u>edit $MYVIMRC<CR>
nnoremap [space], :<C-u>source $MYVIMRC<CR>
"}}}

" =======================================
" Edit
" =======================================

" Edit {{{
set autoindent
set bs=indent,eol,start   " バックスペースが色々消せるように
set nowritebackup         " バックアップを取らない
set nobackup              " バックアップを取らない
set noswapfile            " バックアップを取らない
set viminfo=%,'100,<500,h
set autoread              " 外部で変更された時自動読み込み
set infercase             " 補完時大/小文字修正
set virtualedit=all       " カーソル移動の制限をなくす
set tabstop=2             " タブを何文字として表示するか
set shiftwidth=2          " タブの幅
set shiftround            " swの分の倍数で丸め込み
set smarttab              " shiftwidthの分だけスペース挿入
set expandtab             " タブをスペースに
set incsearch             " 即時検索
set ignorecase            " 検索で大/小文字区別しない
set smartcase             " 検索で大文字で区別
set wrapscan              " 検索末尾で先頭に戻る
set hlsearch              " 検索をハイライト
nohlsearch                " reset highlight
set scrolloff=5           " 5行余裕を持ってスクロール
set noshowmode            " modeによるメッセージを非表示
set wildmenu              " command-lineでのタブ補完
set wildmode=list:full    " 補完時の一覧表示有効化
set showcmd               " 入力中のコマンドを表示
set cmdheight=2           " メッセージ表示欄を2行表示
set laststatus=2          " ステータスラインを常に表示
set history=200           " command-line history
set showmatch             " 開き括弧を表示
set matchtime=1           " 対応する括弧を1秒のみ表示
set modeline              " modelineを有効にする
set hidden                " 保存されていないファイルを開く
set display=uhex          " 表示できない文字を16進数で表示
set splitbelow            " 新しく開くときに下に開く
set splitright            " 新しく開くときに右に開く
set switchbuf=useopen     " 同じウィンドウを使って開く
set textwidth=0           " 自動的な改行無効
set wildoptions=tagfile   " command-lineの補完にtagを追加
set ambiwidth=double      " 2バイト文字を正しく表示

" コメントアウトを継続しない
au FileType * setlocal formatoptions-=ro 


" 編集履歴を保存して終了する{{{
if has('persistent_undo') && isdirectory($HOME.'/.vim/undo')
  set undodir=~/.vim/undo
  set undofile
endif
"}}}

" windows環境では.un~を一箇所にまとめる{{{
if has('kaoriya')
  set undodir=~/.vim/undo
endif
"}}}

" 最後に編集した場所にカーソルを移動する{{{
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
"}}}

" ファイルの位置をカレントディレクトリに{{{
if has("unix")
  au BufEnter *.rb,*.c execute ":lcd" . expand("%:p:h")
  " gitvでエラー出る
  " au BufEnter * execute ":lcd" . expand("%:p:h")
endif
" 編集中のファイルのディレクトリに移動
nnoremap ,d :execute ":lcd" . expand("%:p:h")<CR>
"}}}

" 折り畳み設定 {{{
set foldmethod=marker
nnoremap <silent> ,fc :<C-u>%foldclose<CR>
nnoremap <silent> ,fo :<C-u>%foldopen<CR>
set foldtext=FoldCCtext()
"}}}

" クリップボード{{{
set clipboard^=unnamedplus,unnamed 

" if has("clipboard") 
" vmap ,y "+y 
" nmap ,p "+gP 
" " exclude:{pattern} must be last ^= prepend += append 
" if has("gui_running") || has("xterm_clipboard") 
" silent! set clipboard^=unnamedplus 
" set clipboard^=unnamed 
" endif 
" endif

" set paste
nnoremap <silent> <F1> :<C-u>set paste!<CR>:<C-U>echo("Toggle PasteMode => " . (&paste == 0 ? "Off" : "On"))<CR>
"}}}

" ファイルを整形 {{{
function! s:format_file()
  let view = winsaveview()
  normal gg=G
  silent call winrestview(view)
endfunction
nnoremap [space]i :call <SID>format_file()<CR>
"}}}

" UTF8、SJIS(CP932)、EUCJPで開き直す {{{
command! -bang -nargs=? Utf8
      \ edit<bang> ++enc=utf-8 <args>
command! -bang -nargs=? Sjis
      \ edit<bang> ++enc=cp932 <args>
command! -bang -nargs=? Euc
      \ edit<bang> ++enc=eucjp <args>
" }}}

" Tab {{{

nnoremap <silent> gc :tablast <bar> tabnew<CR>
nnoremap <silent> gl :tabnext<CR>
nnoremap <silent> gh :tabprevious<CR>
nnoremap <silent> gs :tab split<CR>

" tabline
set showtabline=2
nnoremap <silent> <S-Right> :<C-u>tabnext<CR>
nnoremap <silent> <S-Left> :<C-u>tabprevious<CR>
nnoremap <silent> L :<C-u>tabnext<CR>
nnoremap <silent> H :<C-u>tabprevious<CR>
nnoremap [tab]+     :<C-u>tabmove +1<CR>
nnoremap [tab]-     :<C-u>tabmove -1<CR>
"}}}

"}}}

" File別シンタックス設定{{{
au BufRead,BufNewFile,BufReadPre *.slim set filetype=slim
au FileType slim setlocal sw=2 sts=2 ts=2 et
au BufRead,BufNewFile,BufReadPre *.coffee set filetype=coffee
au FileType coffee setlocal sw=2 sts=2 ts=2 et
au FileType yaml setlocal expandtab ts=2 sw=2 fenc=utf-8
au BufRead,BufNewFile,BufReadPre .vimperatorrc set filetype=vimperator
au BufRead,BufNewFile,BufReadPre *.md set filetype=markdown
" markdown で改行がおかしくなるので(謎)
au FileType markdown setlocal indentkeys-=o,O
"}}}

" =======================================
" KeyMap
" =======================================

" key mapping {{{
" Space prefix
nnoremap [space] <Nop>
nmap     <Space> [space]
xmap     <Space> [space]

nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk
" 行頭行末に移動する
noremap [space]h  ^
noremap [space]l  $

" vvで文末まで選択
vnoremap v $h

" window移動
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k

" ハイライトを消す
nnoremap <silent> <C-h><C-h> :nohlsearch<CR><Esc>

noremap [space]w <C-w>

"search center
map * <Plug>(visualstar-*)Nzz
map # <Plug>(visualstar-#)Nzz
nnoremap g* g*zz
nnoremap g# g#zz
nnoremap G Gzz
nnoremap <C-o> <C-o>zz
"}}}

" visual mode 括弧入力  {{{
" from http://vim-users.jp/2011/04/hack214/
vnoremap ( t(
vnoremap ) t)
vnoremap ] t]
vnoremap [ t[
onoremap ( t(
onoremap ) t)
onoremap ] t]
onoremap [ t[
" }}}

" =======================================
" Display
" =======================================

" Display{{{
set title
set number         " 行数を表示 
set nowrap         " 表示を改行させない
set colorcolumn=80 " 80行目にライン
set list           " 不可視文字表示
set ruler          " カーソルを常に表示

" デフォルト不可視文字は美しくないのでUnicodeで綺麗に
set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%,eol:↲

syntax on
set background=dark

" background切り替え
nnoremap ,bl :<C-u>set background=light<CR> 
nnoremap ,bd :<C-u>set background=dark<CR> 

if has('gui_running')
  set t_Co=256
endif

" 全角スペースをハイライト{{{
if has('gui_running')
  MyAutocmd ColorScheme * highlight ZenkakuSpace ctermbg=239 guibg=#405060
  MyAutocmd VimEnter,WinEnter * call matchadd('ZenkakuSpace', '　')
endif
"}}}

" 編集中の行に下線を引く{{{
MyAutocmd InsertLeave * setlocal nocursorline
MyAutocmd InsertEnter * setlocal cursorline
MyAutocmd InsertLeave * highlight StatusLine ctermfg=145 guifg=#c2bfa5 guibg=#000000
MyAutocmd InsertEnter * highlight StatusLine ctermfg=12 guifg=#1E90FF
" 
" MyAutocmd  WinLeave * setlocal nocursorcolumn
" MyAutocmd  WinEnter * setlocal cursorcolumn
"}}}
"}}}

" =======================================
" Plugin Setting
" =======================================

" Unite {{{
nnoremap [unite] <Nop>
nmap <Space>f [unite]

" 最近閉じたファイル
nnoremap <silent> [unite]m   :<C-u>Unite file_mru<CR>
nnoremap <silent> [unite]a   :<C-u>Unite file_mru -buffer-name=files directory_mru file<CR>

nnoremap <silent> [unite]l   :<C-u>Unite -buffer-name=lines line<CR>
nnoremap <silent> [unite]e   :<C-u>Unite file_rec/async:!<CR>
nnoremap <silent> [unite]f   :<C-u>UniteWithBufferDir -buffer-name=files file file/new<CR>
nnoremap <silent> [unite]c   :<C-u>Unite -buffer-name=commands history/command<CR>
nnoremap <silent> [unite]o   :<C-u>Unite -vertical -winwidth=45 -wrap -no-quit -toggle -buffer-name=outline outline<CR>
nnoremap <silent> [unite]b   :<C-u>Unite -buffer-name=bookmark -prompt=bookmark> bookmark<CR>
nnoremap <silent> [unite]r   :<C-u>Unite -buffer-name=register -prompt=">\  register<CR>
nnoremap <silent> [unite]g   :<C-u>Unite -buffer-name=grep grep<CR>
nnoremap <silent> [unite]i   :<C-u>Unite ref/refe -default-action=vsplit<CR>

" yankroundの履歴
nnoremap <silent> [unite]y :<C-u>Unite yankround<CR>
" ユナイトビューティフルアタック！！
nnoremap <silent> [unite]z :<C-u>Unite colorscheme -auto-preview<CR>

let s:bundle = neobundle#get("unite.vim")
function! s:bundle.hooks.on_source(bundle)
  " 高速化
  let g:unite_source_file_mru_filename_format = ''
  " インサートモードで開始
  let g:unite_enable_start_insert = 1
  let g:unite_enable_ignore_case = 1
  let g:unite_enable_smart_case = 1
  " windows環境
  let g:unite_source_grep_encoding='utf-8'

  let g:unite_winheight = 15
  let g:unite_winwidth = 45
  let g:unite_source_grep_max_candidates = 500

  " デフォルトのコンテキストを -prompt-direction=top にする
  call unite#custom#profile('default', 'context', { 'prompt_direction': 'top'})

  " ディレクトリに対するブックマークはvimfilerをデフォルトアクションにする
  call unite#custom_default_action(
        \'source/bookmark/directory', 'vimfiler')

  call unite#custom#source(
        \'buffer,file', 'sorters', 'sorter_rank')

  call unite#custom#source('file_rec,file_rec/async', 'filters',
        \ ['converter_relative_word', 'matcher_default',
        \  'sorter_rank', 'converter_relative_abbr',
        \'converter_file_directory'])

  call unite#custom#source(
        \ 'file_mru', 'converters',
        \ ['converter_file_directory'])

  " 有効・無効を切り替えたい
  " call unite#custom#source('line', 'matchers', 'matcher_migemo')

  function! s:unite_my_settings()
    imap <silent> <buffer> <ESC><ESC> <ESC>q
    nmap <buffer> <ESC> <Plug>(unite_exit)
    imap <buffer> <C-w> <Plug>(unite_delete_backward_path)

    " Overwrite settings.
    nmap <buffer> l     <Plug>(unite_choose_action)
    nmap <buffer> <C-c> <Plug>(unite_choose_action)

    imap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    nmap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-y> <Plug>(unite_narrowing_path)
    nmap <buffer> <C-y> <Plug>(unite_narrowing_path)
    nmap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)

    nmap <silent><buffer><expr> f unite#do_action('vimfiler')
  endfunction
  MyAutocmd FileType unite call s:unite_my_settings()
endfunction
unlet s:bundle
" }}}

" VimShell{{{
nnoremap <silent> vs :<C-u>VimShellBufferDir -split<CR>
nnoremap <silent> ,vs :<C-u>VimShell<CR>

" vimshllの時はwrapしていた方が見やすい
MyAutocmd FileType vimshell setlocal wrap
" MyAutocmd FileType vimshell AnsiEsc

let s:bundle = neobundle#get("vimshell")
function! s:bundle.hooks.on_source(bundle)
  let g:vimshell_prompt = "- "

  let g:vimshell_max_command_history = 3000
  if has('unix')
    let g:vimshell_right_prompt = 'Git_branch() . getcwd()'
  else
    let g:vimshell_right_prompt = 'getcwd()'
  endif

  function! Git_branch()
    " ブランチ名を取得
    " Git管理下でなかったらエラーを/dev/nullへ
    let s:branch = substitute(system("git rev-parse --abbrev-ref HEAD 2> /dev/null"), '\n', '', 'g')

    " 変数があったらブランチ名を返す
    if s:branch == ''
      return ''
    else
      return ' ⭠ ' . s:branch . ' > '
    endif
  endfunction

  function! s:EarthquakeKeyMap()
    nnoremap <buffer><expr> o OpenBrowserLine()
  endfunction
  MyAutocmd FileType int-earthquake call s:EarthquakeKeyMap()
endfunction
unlet s:bundle
"}}}

" VimFiler{{{
nnoremap <silent> ,vf :<C-u>VimFiler<CR>
nnoremap <silent> [space]e :<C-u>VimFilerBufferDir -split -simple -winwidth=35 -no-quit -toggle<CR>
let s:bundle = neobundle#get('vimfiler')
function! s:bundle.hooks.on_source(bundle)
  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_max_directory_histories = 100
  " Like Textmate icons.
  let g:vimfiler_tree_leaf_icon = ' '
  let g:vimfiler_tree_opened_icon = '▾'
  let g:vimfiler_tree_closed_icon = '▸'
  let g:vimfiler_file_icon = '-'
  let g:vimfiler_marked_file_icon = '*'
  function! s:ChangeVimfilerKeymap()
    nmap <space>w <C-w>

    nmap <buffer> s <Plug>(vimfiler_select_sort_type)
    nmap <buffer> @ <Plug>(vimfiler_set_current_mask)
    nmap <buffer> V <Plug>(vimfiler_quick_look)
  endfunction

  MyAutocmd FileType vimfiler call s:ChangeVimfilerKeymap()
endfunction
unlet s:bundle
"}}}

" rubycomplete.vim {{{
MyAutocmd FileType ruby,eruby,slim setlocal omnifunc=rubycomplete#Complete

let g:rubycomplete_rails = 0
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_include_object = 1
let g:rubycomplete_include_object_space = 1
" let ruby_operators = 1
" }}}

" Rails {{{
" 高速移動
nnoremap J :<C-u>A<CR>
nnoremap K :<C-u>R<CR>

nnoremap [rails] <Nop>
nmap [space]j [rails]

" unite rails
nnoremap <silent> [rails]m :<C-u>Unite rails/model<CR>
nnoremap <silent> [rails]v :<C-u>Unite rails/view<CR>
nnoremap <silent> [rails]c :<C-u>Unite rails/controller<CR>
nnoremap <silent> [rails]h :<C-u>Unite rails/helper<CR>
nnoremap <silent> [rails]l :<C-u>Unite rails/lib<CR>
nnoremap <silent> [rails]d :<C-u>Unite rails/db<CR>
nnoremap <silent> [rails]s :<C-u>Unite rails/spec<CR>
nnoremap <silent> [rails]r :<C-u>Unite rails/route<CR>
"}}}

" neosnippet {{{
" 見えてた方が好み
" if has('conceal')
" set conceallevel=2 concealcursor=i
" endif

let g:neosnippet#snippets_directory='~/.vim/bundle/neosnippet-snippets/neosnippets,~/.vim/snippets'
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
xmap <C-l> <Plug>(neosnippet_start_unite_snippet_target)

" http://qiita.com/alpaca_taichou/items/ab2ad83ddbaf2f6ce7fb
" http://qiita.com/muran001/items/4a8ffafb9c6564313893
" enable ruby & rails snippet
function! s:RailsSnippet()
  NeoSnippetSource ~/.vim/snippets/ruby.snip
  if exists("b:rails_root")
    let s:current_file_path = expand("%:p:h")
    " app/modlesフォルダ内
    if ( s:current_file_path =~ "app/models" )
      NeoSnippetSource ~/.vim/snippets/ruby.rails.model.snip
      " app/controllersフォルダ内
    elseif ( s:current_file_path =~ "app/controllers" )
      NeoSnippetSource ~/.vim/snippets/ruby.action_controller.snip
      NeoSnippetSource ~/.vim/snippets/ruby.abstract_controller.snip
      " app/viewsフォルダ内
    elseif ( s:current_file_path =~ "app/views" )
      NeoSnippetSource ~/.vim/snippets/ruby.action_view.snip
      " configフォルダ内
    elseif ( s:current_file_path =~ "config" )
      NeoSnippetSource ~/.vim/snippets/ruby.rails.route.snip
      " dbフォルダ内
    elseif ( s:current_file_path =~ "db" )
      NeoSnippetSource ~/.vim/snippets/ruby.active_record.migration.snip
    endif
  endif
endfunction

MyAutocmd BufEnter * call s:RailsSnippet()
MyAutocmd BufEnter *_spec.rb NeoSnippetSource ~/.vim/snippets/rspec.snip
MyAutocmd BufEnter Gemfile NeoSnippetSource ~/.vim/snippets/Gemfile.snip
MyAutocmd BufEnter *.slim NeoSnippetSource ~/.vim/snippets/bootstrap.snip
"}}}

" neocomplete {{{

" Enable omni completion.
MyAutocmd FileType css,scss setlocal omnifunc=csscomplete#CompleteCSS
MyAutocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
MyAutocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
MyAutocmd FileType sql setlocal omnifunc=sqlcomplete#Complete

if has('lua')
  let s:bundle = neobundle#get('neocomplete')
  function! s:bundle.hooks.on_source(bundle)
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Enable at startup
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1

    " length need to start completion  
    let g:neocomplete#auto_completion_start_length = 2
    let g:neocomplete#manual_completion_start_length = 0
    " 3文字からキャッシュ
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#enable_prefetch = 1

    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
          \ 'default' : '',
          \ 'vimshell' : $HOME . '/.vimshell/command-history',
          \ }

    " キャッシュしないファイル名
    let g:neocomplete#sources#buffer#disabled_pattern = '\.log\|\.log\.\|\.jax'
    " 自動補完を行わないバッファ名
    let g:neocomplete#lock_buffer_name_pattern = '\.log\|\.log\.\|.*quickrun.*\|.jax'

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
      let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-l> neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS>  neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y> neocomplete#close_popup()
    inoremap <expr><C-n> pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.ruby =
          \ '[^. *\t]\.\w*\|\h\w*::'
    " \ '[^. *\t]\.\h\w*\|\h\w*::'
    " if !exists('g:neocomplete#force_omni_input_patterns')
    " let g:neocomplete#force_omni_input_patterns = {}
    " endif
    " let g:neocomplete#force_omni_input_patterns.ruby =
    " \ '[^. *\t]\.\w*\|\h\w*::'

    "インクルード文のパターンを指定
    let g:neocomplete#include_patterns = {
          \ 'ruby' : '^\s*require',
          \ 'javascript' : '^\s*require',
          \ 'coffee' : '^\s*require',
          \ }

    "インクルード先のファイル名の解析パターン
    let g:neocomplete#include_exprs = {
          \ 'ruby' : substitute(v:fname,'::','/','g')
          \ }

    " ファイルを探す際に、この値を末尾に追加したファイルも探す。
    let g:neocomplete#include_suffixes = {
          \ 'ruby' : '.rb',
          \ }
  endfunction
endif
"}}}

" surround.vim {{{
nmap ,( csw(
nmap ,) csw)
nmap ,{ csw{
nmap ,} csw}
nmap ,[ csw[
nmap ,] csw]
nmap ,' csw'
nmap ," csw"
nmap " cs'"
nmap ' cs"'
nmap <C-s> ysW"
"}}}

" submode.vim {{{
let g:submode_timeout = 0
call submode#enter_with('window/manip', 'n', '', ',w')
call submode#leave_with('window/manip', 'n', '', '<Esc>')
call submode#map('window/manip', 'n', '', '<up>', '<C-W>-')
call submode#map('window/manip', 'n', '', '<down>', '<C-W>+')
call submode#map('window/manip', 'n', '', '<left>', '<C-W><')
call submode#map('window/manip', 'n', '', '<right>', '<C-W>>')
" }}}

" vim-gitgitter {{{
let g:gitgutter_sign_added = '✚'
let g:gitgutter_sign_modified = '➜'
let g:gitgutter_sign_removed = '✘'
let g:gitgutter_sign_modified_removed = '✔'
"}}}

" Tabular{{{
nnoremap [tabular] <Nop>
nmap ,a [tabular]
vmap ,a [tabular]
nnoremap [tabular], :Tabularize /,<CR>
vnoremap [tabular], :Tabularize /,<CR>
nnoremap [tabular]= :Tabularize /=<CR>
vnoremap [tabular]= :Tabularize /=<CR>
nnoremap [tabular]> :Tabularize /=><CR>
vnoremap [tabular]> :Tabularize /=><CR>
nnoremap [tabular]: :Tabularize /:\zs<CR>
vnoremap [tabular]: :Tabularize /:\zs<CR>
nnoremap [tabular]<Bar> :Tabularize /<Bar><CR>
vnoremap [tabular]<Bar> :Tabularize /<Bar><CR>
nnoremap [tabular]" :Tabularize /"<CR>
vnoremap [tabular]" :Tabularize /"<CR>
"}}}

" ref.vim{{{
let g:ref_open = 'vsplit'
let g:ref_refe_version = 2
let g:ref_use_vimproc = 1

let g:ref_source_webdict_sites = {
      \   'wikipedia': 'http://ja.wikipedia.org/wiki/%s',
      \   'alc': {
      \      'url': 'http://eow.alc.co.jp/%s/UTF-8/',
      \    },
      \   'ruigo': {
      \      'url': 'http://thesaurus.weblio.jp/content/%s',
      \    },
      \ }

function! g:ref_source_webdict_sites.alc.filter(output)
  return join(split(a:output, "\n")[40 :], "\n")
endfunction
function! g:ref_source_webdict_sites.ruigo.filter(output)
  return join(split(a:output, "\n")[47 :], "\n")
endfunction
MyAutocmd FileType ref-* nnoremap <buffer> <silent> q :<C-u>close<CR>
"}}}

" RSpec syntax {{{
function! RSpecSyntax()
  hi def link rubyRailsTestMethod             Function
  syn keyword rubyRailsTestMethod describe context it its specify shared_examples_for shared_examples shared_context it_should_behave_like it_behaves_like before after around subject fixtures controller_name helper_name include_context include_examples
  syn match rubyRailsTestMethod '\<let\>!\='
  syn keyword rubyRailsTestMethod violated pending expect double mock mock_model stub_model an_instance_of hash_including
  syn match rubyRailsTestMethod '\.\@<!\<stub\>!\@!'
endfunction
MyAutocmd Syntax ruby if (expand("%") =~ "_spec\.rb$") || (expand("%") =~ "^spec.*\.rb$") | call RSpecSyntax() | endif
" }}}

" syntastic {{{
if executable('rubocop')
  let g:syntastic_ruby_checkers = ['mri', 'rubocop']
endif

" let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_mode_map = { 'mode': 'active',
      \ 'active_filetypes': ['ruby'],
      \ 'passive_filetypes': [] }
nmap ,c :<C-u>Errors<CR>
MyAutocmd FileType qf nnoremap <buffer> <silent> q :<C-u>lclose<CR>
"}}}

" open-browser{{{
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
"}}}

" indent-guides {{{
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_guide_size = 1
let g:indent_guides_auto_colors = 0
let g:indent_guides_color_change_percent = 35
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#2f4f4f ctermbg=darkgrey
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#696969 ctermbg=12
" }}}

" TagBar{{{
nnoremap <silent> ,t :TagbarToggle<CR>
" let g:tagbar_left = 1
let g:tagbar_width = 30
let g:tagbar_updateonsave_maxlines = 10000
let g:tagbar_sort = 0
"}}}

" other plugins{{{
" nerdcommenter
let g:NERDCreateDefaultMappings = 0
let NERDSpaceDelims = 1
nmap <Space>/ <Plug>NERDCommenterToggle
vmap <Space>/ <Plug>NERDCommenterToggle

" clever f
let g:clever_f_smart_case = 1
let g:clever_f_use_migemo = 1

" webapi-vim
let g:webapi#system_function = "vimproc#system"

" yankround
" Pのほうが頻度高いのでpとPチェンジ
nmap P <Plug>(yankround-p)
nmap p <Plug>(yankround-P)
nmap <C-p> <Plug>(yankround-prev)
nmap <C-n> <Plug>(yankround-next)
let g:yankround_max_history = 100

" vim-anzu
nmap n <Plug>(anzu-n-with-echo)
nmap N <Plug>(anzu-N-with-echo)
nmap * <Plug>(anzu-star-with-echo)
nmap # <Plug>(anzu-sharp-with-echo)

" sudo.vim
command! ES :e sudo:%
command! WS :w sudo:%

" memo(これが最速)
nnoremap <Space>mm :edit ~/Dropbox/Memo/todo.md<CR>

" ag.vim
let g:agprg="ag --nocolor --nogroup --column"

" vim-over
cnoreabb <silent><expr>s getcmdtype()==':' && getcmdline()=~'^s' ? 'OverCommandLine<CR><C-u>%s/<C-r>=get([], getchar(0), '')<CR>' : 's'

" textobj
omap ab <Plug>(textobj-multiblock-a)
omap ib <Plug>(textobj-multiblock-i)
vmap ab <Plug>(textobj-multiblock-a)
vmap ib <Plug>(textobj-multiblock-i)
"}}}

" lightline {{{
command! -bar LightlineUpdate    call lightline#init()|
      \ call lightline#colorscheme()|
      \ call lightline#update()
let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \           [ 'fugitive', 'filename', 'gitgutter', 'currenttag']],
      \   'right': [ [ 'syntastic', 'percent' , 'absolute'],
      \            [ 'fileformat', 'fileencoding', 'filetype'], 
      \            ['rails'] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'currenttag': 'MyCurrentTag',
      \   'anzu': 'MyAnzu',
      \   'mode': 'MyMode',
      \   'rails': 'MyRails', 
      \   'gitgutter': 'MyGitGutter', 
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': '⮀', 'right': '⮂' },
      \ 'subseparator': { 'left': '⮁', 'right': '⮃' }
      \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '⭤' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'Tagbar' ? g:lightline.fname :
        \ fname =~ 'Gundo' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists("*fugitive#head")
    let _ = fugitive#head()
    return strlen(_) ? '⭠ '._ : ''
  endif
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 80 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 80 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == 'Tagbar' ? 'Tagbar' :
        \ fname == 'Gundo' ? 'Gundo' :
        \ fname == 'Gundo_Preview' ? 'Gundo Preview' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
  let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c call s:syntastic()
augroup END

function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

function! MyCurrentTag()
  let _  = tagbar#currenttag('%s', '')
  return strlen(_) ? _ : ''
endfunction

function! MyAnzu()
  if &ft !~? 'vimfiler\|gundo' && winwidth(0) > 70
    let _ = anzu#search_status()
    return strlen(_) ? _ : ''
  endif
  return ''
endfunction

function! MyRails()
  let s:current_file_path = expand("%:p:h")
  let _  = ''
  if exists("b:rails_root")
    if ( s:current_file_path =~ "app/models" )
      return 'Rails/Modle'
    elseif ( s:current_file_path =~ "app/controllers" )
      return 'Rails/Controller'
    elseif ( s:current_file_path =~ "app/views" )
      return 'Rails/View'
    endif
  endif
  return ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
        \ || ! get(g:, 'gitgutter_enabled', 0)
        \ || winwidth('.') <= 90
    return ''
  endif
  let symbols = [
        \  g:gitgutter_sign_added . ' ' ,
        \  g:gitgutter_sign_modified . ' ' ,
        \  g:gitgutter_sign_removed . ' '
        \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return join(ret, ' ')
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0
"}}}

" Fugitive {{{
nnoremap [git] <Nop>
nmap ,g [git]
nnoremap [git]d :<C-u>Gdiff HEAD<CR>
nnoremap [git]s :<C-u>Gstatus<CR>
" nnoremap [git]l :<C-u>Glog<CR>
nnoremap [git]a :<C-u>Gwrite<CR>
nnoremap [git]c :<C-u>Gcommit<CR>
nnoremap [git]C :<C-u>Git commit --amend<CR>
nnoremap [git]b :<C-u>Gblame<CR>
nnoremap [git]n :<C-u>Git now<CR>
nnoremap [git]N :<C-u>Git now --all<CR>

" ftdetect is often failed
MyAutocmd BufEnter * if expand("%") =~ ".git/COMMIT_EDITMSG" | set ft=gitcommit | endif
MyAutocmd BufEnter * if expand("%") =~ ".git/rebase-merge" | set ft=gitrebase | endif
" }}}

" gitv {{{
nnoremap [git]l :<C-u>Gitv<CR>
nnoremap [git]va :<C-u>Gitv --all<CR>
nnoremap [git]vf :<C-u>Gitv!<CR>

" http://d.hatena.ne.jp/cohama/20130517/1368806202
function! GitvGetCurrentHash()
  return matchstr(getline('.'), '\[\zs.\{7\}\ze\]$')
endfunction

function! s:my_gitv_settings()
  setlocal foldlevel=99

  setlocal iskeyword+=/,-,.
  " カーソル下のブランチ名で checkout
  " ブランチ間移動 r/R
  nnoremap <silent><buffer> C :<C-u>Git checkout <C-r><C-w><CR>

  " カーソル位置のコミットに対する操作
  nnoremap <buffer> <Space>rb :<C-u>Git rebase <C-r>=GitvGetCurrentHash()<CR><Space>
  nnoremap <buffer> <Space>ri :<C-u>Git rebase -i <C-r>=GitvGetCurrentHash()<CR><Space>
  nnoremap <buffer> <Space>R :<C-u>Git revert <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>p :<C-u>Git cherry-pick <C-r>=GitvGetCurrentHash()<CR><CR>
  nnoremap <buffer> <Space>rh :<C-u>Git reset --hard <C-r>=GitvGetCurrentHash()<CR>
endfunction

MyAutocmd FileType gitv call s:my_gitv_settings()
" }}}

" quickrun{{{

" エスケープカラーを表示する。
if has('conceal')
  MyAutocmd FileType quickrun setlocal conceallevel=2
endif
MyAutocmd FileType quickrun AnsiEsc
" ヤンクを取りやすいようにconcealcursorを無効にする。
" MyAutocmd FileType quickrun setlocal concealcursor=""
" quickrunの時はwrapしていた方が見やすい
MyAutocmd FileType quickrun setlocal wrap

call quickrun#module#register(shabadou#make_quickrun_hook_anim(
      \"now_running",
      \['--- Now Running ---', ],
      \40,
      \), 1)

vnoremap ,q :QuickRun >>buffer -mode v<CR>

let g:quickrun_config = {}
let g:quickrun_config._ = {
      \'runner' : 'vimproc',
      \'outputter/buffer/split' : ':botright 8sp',
      \'outputter/error': 'buffer',
      \'runner/vimproc/updatetime' : 40,
      \'hook/now_running/enable' : 1,
      \}

let s:rspec_quickrun_config = {
      \ 'command': 'rspec',
      \ 'outputter/buffer/split': ':botright 8sp',
      \ 'hook/close_buffer/enable_success' : 1,
      \}

let g:quickrun_config['rspec/bundle'] =
      \ extend(copy(s:rspec_quickrun_config), {
      \ 'type': 'rspec/bundle',
      \ 'exec': 'bundle exec %c %o --color --tty %s%a'
      \})

let g:quickrun_config['rspec/normal'] =
      \ extend(copy(s:rspec_quickrun_config), {
      \ 'type': 'rspec/normal',
      \ 'exec': '%c %o --color --tty %s%a'
      \})

let g:quickrun_config['rspec/spring'] =
      \ extend(copy(s:rspec_quickrun_config), {
      \ 'type': 'rspec/spring',
      \ 'exec': 'spring rspec %o --color --tty %s%a'
      \})

function! s:RSpecQuickrun()
  if exists('g:use_spring_rspec') && g:use_spring_rspec == 1
    let b:quickrun_config = {'type' : 'rspec/spring'}
  else
    let b:quickrun_config = {'type' : 'rspec/bundle'}
  endif

  nnoremap <expr><silent> <Leader>lr "<Esc>:QuickRun -args :" . line(".") . "<CR>"
endfunction
MyAutocmd BufReadPost *_spec.rb call s:RSpecQuickrun()

function! s:SetUseSpring()
  let g:use_spring_rspec = 1
endfunction

function! s:SetUseBundle()
  let g:use_spring_rspec = 0
endfunction

command! -nargs=0 UseSpringRSpec let b:quickrun_config = {'type' : 'rspec/spring'} | call s:SetUseSpring()
command! -nargs=0 UseBundleRSpec let b:quickrun_config = {'type' : 'rspec/bundle'} | call s:SetUseBundle()

nnoremap ,r :QuickRun<CR>

let g:quickrun_config['ruby/bundle'] = {
      \ 'command': 'ruby',
      \ 'exec': 'bundle exec %c %s' }

nnoremap ,b :<C-u>UseBundleRuby<CR>

command! -nargs=0 UseBundleRuby
      \ execute ":lcd" . expand("%:p:h") |
      \ let b:quickrun_config = {'type' : 'ruby/bundle'} |
      \ call s:SetUseBundle()
" }}}

" Gem"{{{
function! s:get_all_gem_paths() "{{{
  if exists('s:all_gem_paths')
    return s:all_gem_paths
  endif
  let gem_env = system('rbenv exec gem env')
  let gem_path = matchstr(gem_env, '\(\s*- INSTALLATION DIRECTORY:\s\)\@<=[^\n]*')
  let gem_path .= '/gems/'
  let s:all_gem_paths = split(globpath(gem_path, '*/lib'), '\n')
  return s:all_gem_paths
endfunction"}}}
function! s:get_gem_paths() " {{{
  if !exists('s:gem_path')
    let s:gem_path = {}
  endif
  let project_dir = s:get_vital().import('Prelude').path2project_directory(getcwd())
  if !has_key(s:gem_path, project_dir)
    try
      let paths = map(split(result, '\n'), 'v:val . "/lib"')
      call filter(paths, 'isdirectory(v:val)')
      let s:gem_path[project_dir] = paths
    catch /.*/
      let s:gem_path[project_dir] = s:get_all_gem_paths()
    endtry
  endif
  return s:gem_path[project_dir]
endfunction " }}}
function! s:build_path(path) "{{{
  let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
  if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
    let path = substitute(&g:path,',,$',',','') . ',' . path
  endif
  return path
endfunction"}}}
function! s:set_gem_paths() "{{{
  let gem_paths = join(s:get_gem_paths(), ',')
  if stridx(&l:path, gem_paths) == -1
    execute 'setlocal path+=' . gem_paths
  endif
endfunction"}}}
function! s:get_vital() "{{{
  if !exists('s:V')
    if exists('*neocomplete#util#get_vital')
      let s:V = neocomplete#util#get_vital()
    elseif exists('*unite#util#get_vital')
      let s:V = unite#util#get_vital()
    elseif neobundle#is_installed('vital.vim')
      let s:V = vital#of('vital')
    else
      echomsg 'vital.vim is not found!!'
    endif
  endif
  return s:V
endfunction"}}}
function! s:load_gem_paths() "{{{
  if !empty(s:get_vital())
    call s:set_gem_paths()
  endif
endfunction"}}}
augroup GemPath
  autocmd!
  autocmd FileType Rakefile,ruby call s:load_gem_paths()
augroup END
command! LoadGemPath call s:load_gem_paths()
"}}}
