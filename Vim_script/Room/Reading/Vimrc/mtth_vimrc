" Vim configuration file
"
"
" Standing on the shoulders of giants:
"
" * http://learnvimscriptthehardway.stevelosh.com/
" * https://github.com/skwp/dotfiles/blob/master/vimrc
" * http://amix.dk/vim/vimrc.html
" * https://github.com/scrooloose/vimfiles/blob/master/vimrc
" * https://github.com/bling/dotvim/blob/master/vimrc
" * https://github.com/tpope/vim-sensible
" * https://github.com/spf13/spf13-vim
" * https://github.com/r00k/dotfiles/blob/master/vimrc
" * https://github.com/jbro/vim/blob/master/vimrc
"
"
" Features inspirations from:
"
" * https://github.com/airblade/vim-rooter
" * https://github.com/tpope/vim-unimpaired
" * https://github.com/mileszs/ack.vim
" * https://github.com/bling/vim-bufferline

" CONFIGURATION:

set nocompatible                                                              " allow good thing to happen

" custom runtime path (including optional extra folder)
let g:runtimepath = $HOME . '/.config/vim'
let &runtimepath .= ',' . g:runtimepath . ',' . $HOME . '/.extra/vim'

" environment variables
let g:vimrc_no_plugins = $VIM_NO_PLUGINS == 1                                 " disable all plugins
let g:vimrc_no_options = $VIM_NO_OPTIONS == 1                                 " disable all options (still keeps nocompatible)
let g:vimrc_no_mappings = $VIM_NO_MAPPINGS == 1                               " disable mappings
let g:vimrc_no_autocommands = $VIM_NO_AUTOCOMMANDS == 1                       " disable autocommands

" miscellaneous
let g:project_root_markers = [
\ 'Makefile',
\ 'README.rst', 'README.md',
\ 'venv/',
\ '.git', '.git/'
\ ]                                                                           " markers to find project root directory (note: order matters)
let g:tex_flavor = 'latex'                                                    " use tex filetype by default instead of plaintex
let g:tex_comment_nospell = 1                                                 " don't spellcheck inside tex comments
let g:netrw_home = g:runtimepath . '/cache/netrw'                             " cache directory for file explorer
let g:netrw_banner = 0                                                        " hide help banner (can be shown with `I`)


" PLUGINS AND COLORSCHEMES:

runtime! autoload/pathogen.vim                                                " force autoloading to be able to check if it is installed
if !g:vimrc_no_plugins && !exists('s:loaded_plugins') && exists('*pathogen#infect')

  filetype off                                                                " safe plugin loading

  " Compile
  let g:compile_default_flags = {
  \ 'rst2html': '--stylesheet-path=b.css,p/default.css % &%:r.html',
  \ 'haml': '% &%:r.html',
  \ 'jade': '%',
  \ 'coffee': '%',
  \ 'hamlc': '--input %:h --output &%:h/jst.js',
  \ 'stylus': '%',
  \ 'cc': '% -o &%:r'
  \ }

  " Ctrlp
  let g:ctrlp_by_filename = 0                                                 " search by filename by default
  let g:ctrlp_use_caching = 0                                                 " maybe ag is fast enough
  let g:ctrlp_cmd = 'CtrlP'                                                   " search MRU files by default
  let g:ctrlp_extensions = ['tag']                                            " add tag explorer
  let g:ctrlp_follow_symlinks = 1                                             " follow symbolic links
  let g:ctrlp_lazy_update = 100                                               " wait 250ms after typing before refreshing
  let g:ctrlp_mruf_exclude = '.git'                                           " don't remember these files (for Vim help files)
  let g:ctrlp_mruf_relative = 1                                               " only show MRU files in current working directory
  let g:ctrlp_regexp = 0                                                      " don't use regexp as default search mode
  let g:ctrlp_user_command = 'ag %s --nocolor -g "" -U'                       " use ag as search index
  let g:ctrlp_working_path_mode = 'ra'                                        " use lcd as ctrlp directory

  " Cursorcross
  let g:cursorcross_disable = 0                                               " for debugging
  let g:cursorcross_dynamic = 'cw'                                            " control cursorcolumn and window smart hiding
  let g:cursorcross_exceptions = ['tex']                                      " disable cursorcross for these filetypes

  " Jedi
  let g:jedi#auto_initialization = 0                                          " manual init
  let g:jedi#auto_vim_configuration = 0                                       " manual mapping and 'completeopt'
  let g:jedi#popup_select_first = 0                                           " don't select anything
  let g:jedi#use_tabs_not_buffers = 1                                         " always
  let g:jedi#popup_on_dot = 0                                                 " manual completion
  let g:jedi#show_call_signatures = 0                                         " window doesn't look pretty in command line vim :(

  " LatexBox
  let g:LatexBox_completion_close_braces = 0                                  " don't close braces automatically
  let g:LatexBox_Folding = 0                                                  " special folding for latex
  let g:LatexBox_split_width = 50                                             " width of table of contents

  " Locate
  let g:locate_jump_to = 'closest'                                            " jump to closest match
  let g:locate_refresh = 1                                                    " refresh results on save

  " NERDTree
  let g:NERDTreeMinimalUI = 1                                                 " hide bookmarks and help shortcut
  let g:NERDTreeShowHidden = 0                                                " don't show hidden files (`I` to toggle)
  let g:NERDTreeWinSize = 50                                                  " width of window
  let g:NERDTreeHighlightCursorline = 0                                       " don't highlight the line (out of sync with window shows)

  " Pathogen
  let g:pathogen_disabled = []
  if v:version <# '704' || !has('python')
    call add(g:pathogen_disabled, 'ultisnips')
  endif

  " Scratch
  let g:scratch_height = 0.25                                                 " height of scratch window

  " Surround
  let g:surround_no_mappings = 1                                              " default mappings are bad

  " Syntastic
  let g:syntastic_always_populate_loc_list = 0                                " default but to be safe
  let g:syntastic_auto_jump = 0                                               " note that this option forces location list updates
  let g:syntastic_auto_loc_list = 0                                           " never update location list automatically
  let g:syntastic_loc_list_height = 5                                         " syntastic isn't at all well-behaved about the location list
  let g:syntastic_check_on_open = 0                                           " don't check syntax when opening file
  let g:syntastic_check_on_wq = 0                                             " don't check when closing
  let g:syntastic_echo_current_error = 1                                      " echo current error in command line
  let g:syntastic_enable_balloons = 0                                         " don't show balloons when mouseing over errors
  let g:syntastic_enable_highlighting = 0                                     " don't highlight errors
  let g:syntastic_python_checkers = ['python']                                " pylint is too slow to be checked automatically
  let g:syntastic_cpp_auto_refresh_includes = 1                               " refresh list of includes
  let g:syntastic_cpp_check_header = 1
  let g:syntastic_cpp_include_dirs = ['/usr/local/Cellar/node/0.10.33/include/node/', '/usr/local/lib/node_modules/nan/']

  " Ultisnips
  let g:UltiSnipsSnippetsDir = g:runtimepath . '/snips'                       " directory where to store snippets
  let g:UltiSnipsEditSplit = 'horizontal'                                     " open snippet edit window in horizontal split
  let g:UltiSnipsSnippetDirectories = ['snips']                               " where to look for snippets
  let g:UltiSnipsExpandTrigger = '<c-j>'                                      " key to trigger snippet
  let g:UltiSnipsListSnippets = '<c-y>'                                       " list snippets

  " Virtualenv
  let g:virtualenv_auto_activate = 1                                          " automatically activate any currently active virtualenv
  let g:virtualenv_directory = '.'                                            " directory where to find virtualenv

  " Solarized
  let g:solarized_termtrans = 1                                               " transparent background sometimes
  let g:solarized_visibility = 'normal'                                       " visibility of 'list' characters

  call pathogen#infect()                                                      " load all plugins
  call pathogen#helptags()                                                    " create Vim help tags

  filetype plugin on                                                          " reenable per filetype loading
  syntax enable                                                               " activate syntax highlighting

  let s:loaded_plugins = 1

endif


" OPTIONS:

if !g:vimrc_no_options

  " general
  set diffopt=filler,vertical
  set encoding=utf-8                                                          " en-coh-ding
  set eadirection=hor                                                         " only resize automatically horizontally (cf. ``equalalways`` option)
  set hidden                                                                  " allow hidden buffers
  set lazyredraw                                                              " don't redraw during macros, etc.
  set magic                                                                   " use Vim magic regular expressions by default
  set modelines=0                                                             " read meta stuff from top or bottom of files
  set noautochdir                                                             " cwd is set differently (cf. ``s:smart_chdir`` function below)
  set nostartofline                                                           " keeps cursor on current column for movements like H, M, ...
  set number                                                                  " activate line numbers
  set previewheight=25                                                        " height of preview window
  set sidescrolloff=5                                                         " allow 5 lines left/right of the cursor
  set scrolloff=5                                                             " allow 5 lines below/above the cursor
  set shell=/usr/bin/env\ bash                                                " load .bashrc when starting shell from Vim
  set shellredir=>%s\ 2>&1                                                    " otherwise syntastic isn't able to pick up checker versions
  set shellslash                                                              " use forward slashes for paths, always
  set showcmd                                                                 " show partial command and number of lines/columns selected
  set showtabline=2                                                           " always show tabline (prettier with dark tmux status line)
  set tag=./.tags;,.venvtags                                                  " tags files
  set ttimeoutlen=100                                                         " don't wait a second for wrong key codes to error out
  set virtualedit=block                                                       " let cursor move past the last char in <C-V> mode

  " text formatting
  " `formatlistpath` below is set to recognize three types of lists:
  "
  " * unordered lists: `\s*[*+-]\s`
  " * numbered lists: `\s*\d+[\]:.)}]\s`
  " * description lists: `\s*:[^:]+:\s`
  "
  " it also indents the following lines by 2 spaces.
  set autoindent                                                              " keep indentation when going to new line
  set backspace=indent,eol,start                                              " allow backspace to delete new lines, etc.
  set comments-=:%                                                            " these shouldn't be considered comments by default
  set formatlistpat=^\\s*\\(\\d\\(\\d\\ze\\d*[\\]:.)}]\\\|[\\]:.)}]\\ze\\)\\\|:[^:]\\ze[^:]*:\\\|[*+-]\\)\\s
  if v:version >=# 704
    set formatoptions=rqnlj                                                   " only manual formatting by default
  else
    set formatoptions=rqnl                                                    " j option not supported before 7.4
  endif
  set list                                                                    " show hidden characters (cf. ``listchar`` option below)
  set listchars=tab:¬\ ,trail:·                                               " which hidden characters to show
  set nojoinspaces                                                            " don't insert two spaces after punctuation on a join
  set linebreak                                                               " wrap lines at break characters (cf. ``wrap``)
  set nosmartindent                                                           " don't add extra indents, ever
  set textwidth=0                                                             " no maximum line length by default
  set nowrap                                                                  " don't wrap long lines

  " tabbing
  set expandtab                                                               " insert spaces instead of a tab when tabbing
  set shiftwidth=2                                                            " spaces used for indent keys (>>, ...) and for autoindent
  set shiftround                                                              " round to multiple of shiftwidth when indenting
  set tabstop=2                                                               " number of spaces a tab takes (displayed)

  " autocomplete
  set complete-=i                                                             " what to include when pressing <c-n> and <c-p> in insert mode
  set completefunc=syntaxcomplete#Complete                                    " default user completion using syntax keywords
  set completeopt=longest,menuone                                             " only insert longest common strings of suggestions
  set pumheight=20                                                            " maximum height of popup menu
  set wildignore=*.swp,*.bak,*.pyc,*.class                                    " don't show these files in file autocompletion
  set wildmenu                                                                " allow autocompletion with c-n
  set wildmode=longest,full                                                   " first complete common string before navigating through matches

  " history
  if v:version >=# 703
    let &undodir = g:runtimepath . '/cache/undo'                              " saves directory
    set undofile                                                              " allow persistence of undo history
    set undolevels=1000                                                       " number of operations used
    set undoreload=1000                                                       " number of operations stored
  endif

  " folds
  set fillchars="fold: "                                                      " don't show hyphens after folds
  set foldcolumn=0                                                            " width of the fold column
  set foldopen=mark,quickfix,tag,undo                                         " only open folds when using these commands
  set foldlevelstart=11                                                       " open all folds when opening new file
  set foldmethod=indent                                                       " fold by indent
  set foldminlines=0                                                          " allow folding of single lines
  set foldnestmax=10                                                          " maximum fold level

  " search
  set incsearch                                                               " highlight potential matches as search query is being typed
  set hlsearch                                                                " highlight matches after executing search query
  set noignorecase                                                            " always respect case
  set smartcase                                                               " but in case we don't, respect it when uppercase is present

  " spelling
  let &dictionary = '/usr/share/dict/words,'                                  " files where to load word for dictionary
  let &dictionary .= g:runtimepath . '/spell/custom.utf-8.add'                " completion for use with <c-x><c-k>
  let &spellfile = g:runtimepath . '/spell/custom.utf-8.add'                  " file where to add new dictionary words
  set spell                                                                   " spellcheck on by default, why not?

  " backups and swapfiles
  let &backupdir = g:runtimepath . '/cache/backup'                            " store them here
  let &directory = g:runtimepath . '/cache/swap'                              " we won't create swapfiles, but just in case
  set backup                                                                  " store existing files when overwriting
  set backupskip=/tmp/*,/private/tmp/*                                        " don't backup when editing these files (crontabs namely)
  set noswapfile                                                              " as we said, no swapfiles

  " status line
  set laststatus=2                                                            " always show status line
  set statusline=%<                                                           " truncate on left if too long
  set statusline+=%1{winnr()}:\                                               " buffer number
  set statusline+=%F\                                                         " shortened filepath
  set statusline+=%r                                                          " readonly flag [RO]
  set statusline+=%#pandocStrikeoutTable#                                     " highlighting start
  set statusline+=%y                                                          " filetype
  set statusline+=%#ErrorMsg#                                                 " switch highlighting
  set statusline+=%m                                                          " modified flag [+] (or [-] if nomodifiable is set)
  set statusline+=%*                                                          " end highlighting
  set statusline+=%=                                                          " switch to right side
  set statusline+=\ %c/%{&textwidth}\ %l/%L\ [%p%%]                           " current_column/textwidth current_line/total_lines [percentage]

  " theme
  silent! colorscheme solarized                                               " colorscheme (if available)
  set background=dark                                                         " theme
  if v:version >=# 703
    set colorcolumn=+1                                                        " highlight after textwidth
  endif
  set nocursorcolumn                                                          " don't highlight the current column
  set nocursorline                                                            " or the current row
  set showbreak=                                                              " no characters shown after a linebreak
  set t_Co=256                                                                " terminal colors

  " highlighting overrides
  highlight IncSearch term=reverse cterm=reverse ctermfg=9 gui=reverse
  highlight Locate term=reverse cterm=reverse ctermfg=13
  highlight SignColumn ctermbg=none guibg=none
  highlight VertSplit term=reverse cterm=reverse
  highlight Visual term=reverse cterm=reverse ctermfg=10 ctermbg=0 guibg=DarkGrey

  " disabled
  " syntax sync fromstart                                                     " otherwise folding messes up highlighting
  " set statusline+=%{&modifiable?fugitive#statusline():''}\                  " current git branch (if any and if buffer modifiable)
  " let &viminfo .= ',n' . g:runtimepath . '/cache/info'                      " location of .viminfo file

endif


" MAPPINGS:

if !g:vimrc_no_mappings

  " movements

  " visual up, down
  noremap j gj
  noremap k gk
  " easy scrolling
  noremap <up> <c-u>
  noremap <down> <c-d>
  nnoremap <left> <c-w>h
  nnoremap <right> <c-w>l
  " easy movement around splits
  nnoremap <c-h> <c-w>h
  nnoremap <c-j> <c-w>j
  nnoremap <c-k> <c-w>k
  nnoremap <c-l> <c-w>l
  " other buffer
  nnoremap <s-tab> :b#<cr>
  " and now undo (default U is dangerous)
  nnoremap U <c-r>
  " ^ is hard to hit, also by symmetry with `g_` mapping
  noremap _ ^
  " move cursor in insert mode
  inoremap <C-h> <left>
  inoremap <C-l> <right>
  " mapping diff jumps, d makes more sense
  nnoremap ]d ]c
  nnoremap [d [c

  " editing

  " allow undoing of <c-u> and <c-w>
  inoremap <c-u> <c-g>u<c-u>
  inoremap <c-w> <c-g>u<c-w>
  " don't overwrite registers with single normal mode xs
  nnoremap x "_x
  nnoremap X "_X

  " searches

  " enable search for selected text, forwards (*) or backwards (#)
  xnoremap <silent> * :<c-u>
    \let old_reg=getreg('"')<bar>let old_regtype=getregtype('"')<cr>
    \gvy/<c-r>=substitute(
    \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<cr><cr>
    \:call setreg('"', old_reg, old_regtype)<cr>
  xnoremap <silent> # :<c-u>
    \let old_reg=getreg('"')<bar>let old_regtype=getregtype('"')<cr>
    \gvy?<c-r>=substitute(
    \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<cr><cr>
    \:call setreg('"', old_reg, old_regtype)<cr>

  " commands

  " remap command line
  nnoremap <space> :
  xnoremap <space> :
  " shorter shell commands
  nnoremap ! :!
  xnoremap ! :w !
  " always use command line window otherwise
  nnoremap : q:
  xnoremap : q:

  " miscellaneous

  " spelling
  nnoremap s :set spell!<cr>:set spell?<cr>
  " redraw
  nnoremap ' :nohl<cr><c-l>:syntax sync fromstart<cr>
  " easier indentation in visual mode
  xnoremap > >gv
  xnoremap < <gv
  " copying (consistency with C and D)
  nnoremap Y y$
  " arglist
  nnoremap <leader>a :args<cr>
  " show locations of latest changes
  nnoremap <leader>J :changes<cr>
  " show latest jumps
  nnoremap <leader>j :jumps<cr>
  " show messages
  nnoremap <leader>M :messages<cr>
  " show marks
  nnoremap <leader>m :marks<cr>
  " browse oldfiles
  nnoremap <leader>o :browse oldfiles<cr>
  " show registers
  nnoremap <leader>r :registers<cr>
  " copy to tmux buffer
  xnoremap <leader>t :w !tmux loadb -<cr>

  " languages

  " omnicompletion shortcut and menu closer
  inoremap <expr> <c-e> pumvisible() ? "\<c-e>" : "\<c-x>\<c-o>"

  " Vim
  " open .vimrc (following potential symbolic link)
  nnoremap <leader>ve :tabnew <c-r>=resolve(expand($MYVIMRC))<cr><cr>:help<cr><c-w>L:vertical resize 80<cr>:set winfixwidth<cr><c-w>h
  "source .vimrc (and rerun any filetype settings)
  nnoremap <leader>vs :source $MYVIMRC<cr>:filetype detect<cr>

  " function mappings

  " smart indentation
  inoremap <expr> <s-tab> <SID>smart_tab()
  " inplace join (removing whitespace after `([`), also remapping default join
  nnoremap yj J(
  nnoremap <silent> J :call <SID>join_and_trim('[([]')<cr>
  " expand inline parenthesis arguments to multiline
  nnoremap gJ 0f(a<cr><esc>f)i<cr><esc>kI<tab><esc>0dw:s/\v,\s+/,\r/g<cr>``<c-v>``I<c-r>"<esc>``A
  " toggle line numbers (Ex mode can also be entered with ``gQ``, with bonus editing features)
  nnoremap <silent> Q :call <SID>toggle_relativenumber(-1)<cr>
  " pasting (inspired by unimpaired.vim, cf. above)
  nnoremap <silent> ya  :call <SID>toggle_paste(1)<cr>a
  nnoremap <silent> yi  :call <SID>toggle_paste(1)<cr>i
  nnoremap <silent> yo  :call <SID>toggle_paste(1)<cr>o
  nnoremap <silent> yO  :call <SID>toggle_paste(1)<cr>O
  nnoremap <silent> yA  :call <SID>toggle_paste(1)<cr>A
  nnoremap <silent> yI  :call <SID>toggle_paste(1)<cr>I

  if !g:vimrc_no_plugins

    " ctrlp
    nnoremap <c-n> :CtrlPBuffer<cr>
    " nerdtree
    nnoremap <expr> <silent> <leader>e nerdtree#isTreeOpen() ? ":call nerdtree#putCursorInTreeWin()\<cr>" : ":NERDTree\<cr>"
    nnoremap <silent> <leader>E :NERDTreeFind<cr>
    " fugitive
    nnoremap <silent> <leader>gH :Git lo<cr>
    nnoremap <silent> <leader>gL :Glog --<cr>:botright copen<cr>:redraw!<cr>
    nnoremap <silent> <leader>gc :Gcommit -a<cr>
    nnoremap <silent> <leader>gD :Git diff<cr>
    nnoremap <silent> <leader>gd :Gdiff<cr>
    nnoremap <silent> <leader>ge :Gedit<cr>
    nnoremap <silent> <leader>gh :Git hi<cr>
    nnoremap <silent> <leader>gl :Gllog<cr>:lopen<cr><c-w>p:redraw!<cr>
    nnoremap <silent> <leader>gp :Git push<cr>
    nnoremap <silent> <leader>gs :Gstatus<cr>
    " Zurround
    nmap dz <Plug>Dsurround
    nmap cz <Plug>Csurround
    nmap yz <Plug>Ysurround
    nmap yZ <Plug>YSurround
    nmap yzz <Plug>Yssurround
    nmap yZZ <Plug>YSsurround
    xmap z <Plug>VSurround
    xmap Z <Plug>VgSurround
    " syntastic
    nnoremap <silent> S :SyntasticToggle<cr>

  endif

endif


" AUTOCOMMANDS:

if !g:vimrc_no_autocommands

  " general events
  augroup eventgroup
    autocmd!
    autocmd   VimEnter            *         silent call <SID>create_next_mappings()
    autocmd   InsertLeave         *         silent call <SID>toggle_paste(0)
  augroup END

  " some plugin autocommmands
  augroup plugingroup
    autocmd!
    autocmd   BufWritePost        *         silent call <SID>tags_refresh(0, 0)
    autocmd   BufEnter            *         if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
  augroup END

  " fixing some filetypes
  augroup filetypegroup
    autocmd!
    autocmd   BufNewFile,BufRead  *.hamlc   set filetype=haml
    autocmd   BufNewFile,BufRead  *.jst     set filetype=javascript
    autocmd   BufNewFile,BufRead  *.gradle  set filetype=groovy
    autocmd   BufNewFile,BufRead  *.job     set filetype=jproperties
  augroup END

  " plugins

endif


" COMMANDS:

" Ag:
"   :Ag[!] [[OPTIONS] EXPR [FILE ...]]
"
"   Ag for matches of the regexp EXPR. If one or more FILE is specified,
"   only these files are searched, otherwise the entire project directory will
"   be explored. Any matches are loaded in the quickfix window. This
"   implementation is simpler than that of ack.vim
"   (https://github.com/mileszs/ack.vim), uses `ag`, doesn't rely on monkey
"   patching the grep command, and highlights results in the quickfix window.
"
" Arguments:
"   !                                   Load the first match.
"   OPTIONS, EXPR, FILE                 These arguments are forwarded to
"                                       the ag executable (along with the `-H`
"                                       flag to guarantee that the filename
"                                       is always present even when searching
"                                       inside a single file, otherwise the
"                                       quickfix window will fail). Cf.
"                                       `man ag` for details. Note that
"                                       special characters must be escaped or
"                                       quoted. If omitted, the previous ag
"                                       search will be repeated.
"
" Examples:
"   :Ag! hello                          Ag for hello in project directory
"                                       and open first match.
"   :Ag '\bthe\b' %                     Ag for occurrences of the word
"                                       `the` in the current file.
"
command! -bang -nargs=* -complete=file Ag call <SID>ag(<bang>0, <q-args>)

" OpenInPreviousWindow:
"   :OpenInPreviousWindow[!] COMMAND
"
"   This is useful in particular for quickfix (which otherwise always uses the
"   rightmost one) Note that the cursor in the window the command would have
"   loaded in will always be in the same position in the text but its position
"   relative to the window might be different.
"
" Arguments:
"   !                                   Force command to load in previous
"                                       window even if the cursor stays in the
"                                       current window.
"   COMMAND                             The command to execute.
"
command! -bang -nargs=* OpenInPreviousWindow call <SID>open_in_previous_window(<bang>0, <q-args>)

" TagsRefresh:
"   :TagsRefresh[!]
"
"   This command will update the taglist (if open) and run ctags recursively
"   if the file is in a git repository (and error out otherwise).
"
" Arguments:
"   !                                   Also refresh virtual environment tags.
"                                       By default this commands skips these.
"
command! -bang TagsRefresh call <SID>tags_refresh(<bang>0, 1)

" Retab:
"   :[RANGE]Retab BEFORE AFTER
"
"   This command will retab a file from BEFORE spaces per tab to AFTER spaces
"   per tab.
"
" Arguments:
"   RANGE                               Optional range to retab
"   BEFORE                              Initial number of spaces per tab
"   AFTER                               Desired number of spaces per tab

command! -range=% -nargs=* Retab <line1>,<line2>call <SID>retab(<f-args>)

" Sanitize:
"   :[RANGE]Sanitize
"
"   Remove shell escape codes.
"
command! -range Sanitize <line1>,<line2>s:\v(\[[0-9;]*[mK]|M)::g

" Chdir:
"   :Chdir[!] [PATH]
"
"   Change local working directory to the project root of the current open
"   file (as defined by `g:project_root_markers`).
"
" Arguments:
"   !                                   Don't move all the way up to project
"                                       but stay in current file's directory.
"   PATH                                Path to file or directory. If a file,
"                                       its parent directory will be used. By
"                                       default the path to the current open
"                                       file will be used.
"
command! -bang -nargs=? -complete=file Chdir call <SID>smart_chdir(<q-args>, <bang>0)


" FUNCTIONS:

" Helpers

function! s:smart_tab()
  " fills in line with character before cursor until one of the following
  " * matches indent of characters preceded by two or more whitespace characters
  "   in the first non-empty line above
  " * texwidth
  " * next tabstop
  " if the current line is empty, the fill character will be a single space
  let [buf_name, line_number, col_number, off_number] = getpos('.')
  let cur_line = getline(line_number)
  if strlen(cur_line)
    let fill_char = cur_line[col('.') - 2]
  else
    let fill_char = ' '
  endif
  let line_content = ''
  while !strlen(line_content) && line_number >=# 1
    let line_number -= 1
    let line_content = getline(line_number)
  endwhile
  let line_content = line_content[col('.') - 1:]
  let offset = match(line_content, '\s\s\zs\S\|$')
  if offset ># 0
    return repeat(fill_char, offset)
  elseif &textwidth && col_number <=# &textwidth
    return repeat(fill_char, &textwidth - col_number + 1)
  else
    return repeat(fill_char, &tabstop - (col_number - 1) % &tabstop)
  endif
endfunction

function! s:join_and_trim(pattern)
  " join lines and remove inserted whitespace if current line ends in pattern
  let cur_line = getline('.')
  let cur_line_length = strlen(cur_line)
  execute 'normal! J'
  if cur_line_length ># 0
    let last_char = cur_line[cur_line_length - 1]
    if match(last_char, a:pattern) >=# 0
      execute 'normal! x'
    endif
  endif
endfunction

function! s:get_visual_selection()
  " get visual selection
  " copied from http://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

function! s:open_in_previous_window(force, cmd)
  " a force command to load in previous window (cf. OpenInPreviousWindow command above for details)
  let l:bwnr = winnr()
  let l:pwnr = winnr('#')
  execute a:cmd
  let l:cwnr = winnr()
  " we check if the cursor has moved window and if it isn't already in the correct one
  if (l:cwnr !=# l:bwnr || a:force) && l:cwnr !=# l:pwnr
    let l:cbnr = bufnr('%')
    let l:view = winsaveview()
    execute "normal! \<c-o>"
    execute l:pwnr . 'wincmd w'
    execute 'hide buf' l:cbnr
    call winrestview(l:view)
  endif
endfunction

function! s:retab(before, after) range
  " cf. Retab command for details
  let tabstop_save = &tabstop
  let &tabstop = str2nr(a:before)
  let range = a:firstline . ',' . a:lastline
  set noexpandtab
  execute range . 'retab!'
  let &tabstop = str2nr(a:after)
  set expandtab
  execute range . 'retab!'
  let &tabstop = tabstop_save
endfunction

" Smart autochdir

function! s:get_project_root(start_dir, markers)
  " get root of current project. markers corresponding to directories must end
  " with a /
  " if no project root is found upstream, returns start_dir
  let dir_current_file = fnameescape(a:start_dir)
  for marker in a:markers
    if match(marker, '/') !=# -1
      let marker_path = finddir(marker, dir_current_file . ';')
      if !empty(marker_path)
        return fnamemodify(marker_path, ':p:h:h')
      endif
    else
      let marker_path = findfile(marker, dir_current_file . ';')
      if !empty(marker_path)
        return fnamemodify(marker_path, ':p:h')
      endif
    endif
  endfor
  return a:start_dir
endfunction

function! s:smart_chdir(path, use_current_dir)
  " set local working directory to project directory (marked by presence of
  " certain files) or to current file's directory. this will raise an error
  " if not used when an existing normal file is open
  if strlen(a:path)
    let dpath = a:path
  elseif match(expand('%:p'), '^\w\+:/.*') ==# -1 && empty(&buftype)
    let dpath = expand('%:p')
  else
    echoerr 'Unable to find valid working directory.'
  endif
  if !isdirectory(dpath)
    let dpath = fnamemodify(dpath, ':h')
  endif
  if !a:use_current_dir
    let dpath = s:get_project_root(dpath, g:project_root_markers)
  endif
  execute ':lcd ' . fnameescape(dpath)
  echomsg 'CWD changed to: ' . getcwd()
endfunction

" Tags

function! s:tags_refresh(venv, force)
  " (cf. TagsRefresh command above for details)
  if bufloaded('__Tag_List__')
    TlistUpdate
    echo 'Taglist updated!'
  endif
  if bufloaded('__Tag_List__') || a:force
    if !empty(finddir('.git'))
      call system('ctags -R --exclude=venv')
      echo 'Project tags updated!'
    else
      echoerr "Can't compile project tags, git repository not found in root."
    endif
  endif
  if a:venv && filewritable('venv') ==# 2
    call system('ctags -Rf .venvtags venv')
    echo 'Project virtual environment tags updated!'
  endif
endfunction

" Ag

function! s:ag(force, args)
  " cf. Ag command above for explanations
  cclose
  if strlen(a:args)
    let s:search_args = a:args
  endif
  if !exists('s:search_args')
    redraw!
    echo 'No search term found.'
  else
    echo 'Searching...'
    let cmd = 'ag --nocolor --nogroup ' . s:search_args
    let shellredir_save = &shellredir
    let &shellredir = '>%s 2>&1'
    let l:results = system(cmd)
    let &shellredir = shellredir_save
    if strlen(l:results)
      if v:shell_error ># 0
        echoerr 'Invalid ag expression'
        echo l:results
      else
        let errorformat_save = &errorformat
        let &errorformat = '%f:%l:%m'
        if a:force
          cexpr l:results
        else
          cgete l:results
        endif
        let &errorformat = errorformat_save
        let errors_found = len(getqflist())
        if errors_found ># 0
          execute 'copen ' . min([20, errors_found])
          call matchadd('Search', '\v' . s:search_args)
          redraw!
          echo line('$') . ' result(s) found'
        else
          redraw!
          echo 'No results parsed'
        endif
      endif
    else
      redraw!
      echo 'No results found'
    endif
  endif
endfunction

" Unimpaired mappings

function! s:map_next_family(map,cmd)
  " previous and next mappings factory
  " copied from unimpaired.vim by tim pope, https://github.com/tpope/vim-unimpaired/
  let map = '<Plug>unimpaired'.toupper(a:map)
  let end = ' ".(v:count ? v:count : "")<CR>'
  execute 'nnoremap <silent> '.map.'Previous :<C-U>exe "'.a:cmd.'previous'.end
  execute 'nnoremap <silent> '.map.'Next     :<C-U>exe "'.a:cmd.'next'.end
  execute 'nnoremap <silent> '.map.'First    :<C-U>exe "'.a:cmd.'first'.end
  execute 'nnoremap <silent> '.map.'Last     :<C-U>exe "'.a:cmd.'last'.end
  execute 'nmap <silent> ['.        a:map .' '.map.'Previous'
  execute 'nmap <silent> ]'.        a:map .' '.map.'Next'
  execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'
  execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'
endfunction

function! s:create_next_mappings()
  " create unimpaired mappings
  call s:map_next_family('a','')
  call s:map_next_family('b','b')
  call s:map_next_family('c','c')
  call s:map_next_family('l','l')
  call s:map_next_family('t','t')
endfunction

function! s:toggle_paste(force) abort
  " also inspired by unimpaired.vim by tim pope, https://github.com/tpope/vim-unimpaired/
  if a:force
    let s:paste = &paste
    set paste
  else
    if exists('s:paste')
      let &paste = s:paste
      unlet s:paste
    endif
  endif
endfunction

" Various toggles

function! s:toggle_relativenumber(force)
  " toggle number/relativenumber (force = 0 to set number, force = 1 to set relativenumber)
  " note that if neither option is on, and force is different from 0 and 1, nothing will happen
  if a:force ==# 0 || (&number && !&relativenumber)
    set relativenumber
  elseif a:force ==# 1 || &relativenumber
    set norelativenumber
  endif
endfunction


" EXTRA:

" source extra vimrc if it exists
let s:extra_vimrc = $HOME . '/.extra/vimrc'
if filereadable(s:extra_vimrc)
  execute 'source ' . s:extra_vimrc
endif


" FUTURE:

" changes/fixes/ideas

" locate:
" auto scrolling of matches as scrolling window
" rst:
" better highlighting (indented code, links, etc.)
" rst highlighting in python docstrings
" follow links from rst reference

" cursorcross: row highlight gets confused with nerdtree

" gundo avoid resize craziness
" fugitive bug fixes

" execute command without moving cursor in window
" doesn't work currently (doesn't do anything)
" function! s:run_in_place(cmd)
"   let l:view = winsaveview()
"   " silent execute 'normal! ' . a:cmd
"   silent execute a:cmd
"   " call winrestview(l:view)
"   " redraw!
" endfunction
" command! -nargs=* RunInPlace call <SID>run_in_place(<q-args>)

" snip to pbcopy (using reattach-to-namespace if $TMUX)
" unclear how to do over ssh
